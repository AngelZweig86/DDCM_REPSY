#!/usr/bin/env python
""" This module implements some fixed tests.
"""

# project library
import numpy as np
import shutil
import glob
import sys
import os

# project library
sys.path.insert(0, os.environ['ROBUPY'])

# virtual environment
if not hasattr(sys, 'real_prefix'):
    raise AssertionError('Please use a virtual environment for testing')

from robupy import *

''' Auxiliary functions
'''


def compile_package(which):
    """ Compile toolbox
    """
    # Antibugging
    assert (which in ['fast', 'slow'])

    # Auxiliary objects
    package_dir = os.environ['ROBUPY'] + '/robupy'
    tests_dir = os.getcwd()

    # Compile package
    os.chdir(package_dir)

    os.system('./waf distclean > /dev/null 2>&1')

    cmd = './waf configure build'

    if which == 'fast':
        cmd += ' --fast'

    cmd += ' > /dev/null 2>&1'

    os.system(cmd)

    os.chdir(tests_dir)


def cleanup():
    """ Cleanup after test battery.
    '"""
    files = []

    files = files + glob.glob('*.pkl')

    files = files + glob.glob('*.txt')

    files = files + glob.glob('*.dat')

    files = files + glob.glob('*.info')

    files = files + glob.glob('*.log')

    for file_ in files:

        try:

            os.remove(file_)

        except OSError:

            pass

        try:

            shutil.rmtree(file_)

        except OSError:

            pass


def test_1():
    """ Test solution of simple model against hard-coded results.
    """
    robupy_obj = read('first.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()

    # Extract input
    periods_emax = robupy_obj.get_attr('periods_emax')

    # Evaluate statistic
    np.testing.assert_allclose(periods_emax[0, :1], [103320.40501])


def test_2():
    """ Compare the solution of simple model against hard-coded results.
    """
    robupy_obj = read('second.robupy.ini')

    robupy_obj = solve(robupy_obj)

    # Distribute class attributes
    periods_emax = robupy_obj.get_attr('periods_emax')

    ex_post = robupy_obj.get_attr('periods_payoffs_ex_post')

    ex_ante = robupy_obj.get_attr('periods_payoffs_ex_ante')

    # GENERAL: As there are no random disturbances, the ex ante and
    # ex post versions of the period payoffs should be identical.
    assert (np.ma.all(np.ma.masked_invalid(ex_post) ==
                      np.ma.masked_invalid(ex_ante)))

    # PERIOD 3: Check the ex ante payoffs against hand calculations.
    vals = [[2.7456010000000000, 07.5383250000000000, -3999.60, 1.140]]
    vals += [[3.0343583944356758, 09.2073308658822519, -3999.60, 1.140]]
    vals += [[3.0343583944356758, 09.2073308658822519, 0000.90, 1.140]]
    vals += [[3.3534846500000000, 11.2458593100000000, 0000.40, 1.140]]
    vals += [[3.5966397255692826, 12.0612761204447200, -3999.60, 1.140]]
    vals += [[3.9749016274947495, 14.7316759204425760, -3999.60, 1.140]]
    vals += [[3.9749016274947495, 14.7316759204425760, 0000.90, 1.140]]
    vals += [[6.2338866585247175, 31.1869581683094590, -3999.60, 1.140]]
    vals += [[3.4556134647626764, 11.5883467192233920, -3999.60, 1.140]]
    vals += [[3.8190435053663370, 14.1540386453758080, -3999.60, 1.140]]
    vals += [[3.8190435053663370, 14.1540386453758080, 0000.90, 1.140]]
    vals += [[4.5267307943142532, 18.5412874597468690, -3999.60, 1.140]]
    vals += [[5.5289614776240041, 27.6603505585167470, -3999.60, 1.140]]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(ex_ante[2, i, :], val))

    # PERIOD 3: Check expected future values. As there are no
    # random disturbances, this corresponds to the maximum
    # value in the last period.
    vals = [7.53832493366, 9.20733086588, 9.20733086588, 11.2458593149]
    vals += [12.06127612040, 14.7316759204, 14.7316759204, 31.1869581683]
    vals += [11.58834671922, 14.1540386453, 14.1540386453, 18.5412874597]
    vals += [27.660350558516747]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(periods_emax[2, i], [val]))

    # PERIOD 2: Check the ex ante payoffs against hand calculations.
    vals = [[2.7456010150169163, 07.5383249336619222, -3999.60, 1.140]]
    vals += [[3.0343583944356758, 09.2073308658822519, 0000.90, 1.140]]
    vals += [[3.5966397255692826, 12.0612761204447200, -3999.60, 1.140]]
    vals += [[3.4556134647626764, 11.5883467192233920, -3999.60, 1.140]]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(ex_ante[1, i, :], val))

    # PERIOD 2: Check expected future values.
    vals = [18.9965372481, 23.2024229903, 41.6888863803, 29.7329464954]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(periods_emax[1, i], [val]))

    # PERIOD 1: Check the ex ante payoffs against hand calculations.
    vals = [[2.7456010150169163, 7.5383249336619222, 0.90, 1.140]]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(ex_ante[0, i, :], val))

    # PERIOD 1 Check expected future values.
    vals = [47.142766995]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(periods_emax[0, 0], [val]))


def test_3():
    """ THIRD: Check the simulation output for the special case.
    """
    robupy_obj = read('second.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()


def test_4():
    """ Test the solution of model with ambiguity against hard coded results
    to detect unwanted deviations.
    """
    # Relative Criterion
    robupy_obj = read('third.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()

    # Assert unchanged value
    np.testing.assert_allclose(robupy_obj.get_attr('periods_emax')[0, :1],
                               74747.851153)

    # Absolute Criterion
    robupy_obj = read('fourth.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()

    # Assert unchanged value
    np.testing.assert_allclose(robupy_obj.get_attr('periods_emax')[0, :1],
                               44.843587)


def test_5():
    """ Ensure that state space is the same regardless of PYTHON and FORTRAN
        implementation.
    """

    compile_package('fast')

    import robupy.performance.fortran.fortran_core as fort
    import robupy.performance.python.python_core as py


    for _ in range(25):

        # Create grid of admissible state space values.
        num_periods = np.random.random_integers(1, 15)
        edu_start = np.random.random_integers(1, 5)
        edu_max = edu_start + np.random.random_integers(1, 5)

        # Prepare interface
        min_idx = min(num_periods, (edu_max - edu_start + 1))

        # FORTRAN
        fort_a, fort_b, fort_c = fort.create_state_space(num_periods, edu_start,
                                                         edu_max, min_idx)

        # PYTHON
        py_a, py_b, py_c = py.create_state_space(num_periods, edu_start,
                                                         edu_max, min_idx)

        # Ensure equivalence
        for obj in [[fort_a, py_a], [fort_b, py_b], [fort_c, py_c]]:
            np.testing.assert_allclose(obj[0], obj[1])


''' Main
'''
np.random.seed(4536)

test_1()

test_2()

test_3()

test_4()

test_5()
