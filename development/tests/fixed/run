#!/usr/bin/env python
""" This module implements some fixed tests.
"""

# standard library
import numpy as np
import shutil
import glob
import sys
import os

# testing library
sys.path.insert(0, os.environ['ROBUPY'] + '/development/tests/random')
from modules.auxiliary import compile_package

# project library
sys.path.insert(0, os.environ['ROBUPY'])

# virtual environment
if not hasattr(sys, 'real_prefix'):
    raise AssertionError('Please use a virtual environment for testing')
from robupy import *



''' Auxiliary functions
'''

def cleanup():
    """ Cleanup after test battery.
    '"""
    files = []

    files = files + glob.glob('*.pkl')

    files = files + glob.glob('*.txt')

    files = files + glob.glob('*.dat')

    files = files + glob.glob('*.info')

    files = files + glob.glob('*.log')

    for file_ in files:

        try:

            os.remove(file_)

        except OSError:

            pass

        try:

            shutil.rmtree(file_)

        except OSError:

            pass


def test_1():
    """ Test solution of simple model against hard-coded results.
    """
    robupy_obj = read('first.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()

    # Extract input
    periods_emax = robupy_obj.get_attr('periods_emax')

    # Evaluate statistic
    np.testing.assert_allclose(periods_emax[0, :1], [103320.40501])


def test_2():
    """ Compare the solution of simple model against hard-coded results.
    """
    robupy_obj = read('second.robupy.ini')

    robupy_obj = solve(robupy_obj)

    # Distribute class attributes
    periods_emax = robupy_obj.get_attr('periods_emax')

    ex_post = robupy_obj.get_attr('periods_payoffs_ex_post')

    ex_ante = robupy_obj.get_attr('periods_payoffs_ex_ante')

    # GENERAL: As there are no random disturbances, the ex ante and
    # ex post versions of the period payoffs should be identical.
    assert (np.ma.all(np.ma.masked_invalid(ex_post) ==
                      np.ma.masked_invalid(ex_ante)))

    # PERIOD 3: Check the ex ante payoffs against hand calculations.
    vals = [[2.7456010000000000, 07.5383250000000000, -3999.60, 1.140]]
    vals += [[3.0343583944356758, 09.2073308658822519, -3999.60, 1.140]]
    vals += [[3.0343583944356758, 09.2073308658822519, 0000.90, 1.140]]
    vals += [[3.3534846500000000, 11.2458593100000000, 0000.40, 1.140]]
    vals += [[3.5966397255692826, 12.0612761204447200, -3999.60, 1.140]]
    vals += [[3.9749016274947495, 14.7316759204425760, -3999.60, 1.140]]
    vals += [[3.9749016274947495, 14.7316759204425760, 0000.90, 1.140]]
    vals += [[6.2338866585247175, 31.1869581683094590, -3999.60, 1.140]]
    vals += [[3.4556134647626764, 11.5883467192233920, -3999.60, 1.140]]
    vals += [[3.8190435053663370, 14.1540386453758080, -3999.60, 1.140]]
    vals += [[3.8190435053663370, 14.1540386453758080, 0000.90, 1.140]]
    vals += [[4.5267307943142532, 18.5412874597468690, -3999.60, 1.140]]
    vals += [[5.5289614776240041, 27.6603505585167470, -3999.60, 1.140]]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(ex_ante[2, i, :], val))

    # PERIOD 3: Check expected future values. As there are no
    # random disturbances, this corresponds to the maximum
    # value in the last period.
    vals = [7.53832493366, 9.20733086588, 9.20733086588, 11.2458593149]
    vals += [12.06127612040, 14.7316759204, 14.7316759204, 31.1869581683]
    vals += [11.58834671922, 14.1540386453, 14.1540386453, 18.5412874597]
    vals += [27.660350558516747]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(periods_emax[2, i], [val]))

    # PERIOD 2: Check the ex ante payoffs against hand calculations.
    vals = [[2.7456010150169163, 07.5383249336619222, -3999.60, 1.140]]
    vals += [[3.0343583944356758, 09.2073308658822519, 0000.90, 1.140]]
    vals += [[3.5966397255692826, 12.0612761204447200, -3999.60, 1.140]]
    vals += [[3.4556134647626764, 11.5883467192233920, -3999.60, 1.140]]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(ex_ante[1, i, :], val))

    # PERIOD 2: Check expected future values.
    vals = [18.9965372481, 23.2024229903, 41.6888863803, 29.7329464954]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(periods_emax[1, i], [val]))

    # PERIOD 1: Check the ex ante payoffs against hand calculations.
    vals = [[2.7456010150169163, 7.5383249336619222, 0.90, 1.140]]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(ex_ante[0, i, :], val))

    # PERIOD 1 Check expected future values.
    vals = [47.142766995]
    for i, val in enumerate(vals):
        (np.testing.assert_allclose(periods_emax[0, 0], [val]))


def test_3():
    """ THIRD: Check the simulation output for the special case.
    """
    robupy_obj = read('second.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()


def test_4():
    """ Test the solution of model with ambiguity against hard coded results
    to detect unwanted deviations.
    """
    # Relative Criterion
    robupy_obj = read('third.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()

    # Assert unchanged value
    np.testing.assert_allclose(robupy_obj.get_attr('periods_emax')[0, :1],
                               76675.492098)

    # Absolute Criterion
    robupy_obj = read('fourth.robupy.ini')

    robupy_obj = solve(robupy_obj)

    simulate(robupy_obj)

    cleanup()

    # Assert unchanged value
    np.testing.assert_allclose(robupy_obj.get_attr('periods_emax')[0, :1],
                               72.026643)

''' Main
'''
np.random.seed(4536)

test_1()

test_2()

test_3()

test_4()
