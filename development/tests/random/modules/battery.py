
""" This modules contains some additional tests that are only used in
long-run development tests.
"""

# standard library
from pandas.util.testing import assert_frame_equal
import pandas as pd
import numpy as np
import sys
import os

# project library
from modules.auxiliary import compile_package, transform_robupy_to_restud

# ROBUPY import
sys.path.insert(0, os.environ['ROBUPY'])
from robupy.tests.random_init import generate_random_dict, print_random_dict
from robupy import read, solve, simulate

''' Main
'''


def test_97():
    """ Compare results between FORTRAN and PYTHON of selected functions. The
    file python/f2py/debug_interface.f90 provides the F2PY bindings.
    """
    # Ensure that fast solution methods are available
    compile_package('fast')

    import robupy.python.f2py.f2py_debug as fort

    for _ in range(1000):

        # Draw random requests for testing purposes.
        num_draws = np.random.random_integers(1, 1000)
        dim = np.random.random_integers(1, 6)
        mean = np.random.uniform(-0.5, 0.5, (dim))

        matrix = (np.random.multivariate_normal(np.zeros(dim), np.identity(dim), dim))
        cov = np.dot(matrix, matrix.T)

        # Inverse
        py = np.linalg.inv(cov)
        f90 = fort.wrapper_inverse(cov, dim)
        np.testing.assert_allclose(py, f90, rtol=1e-05, atol=1e-06)

        # Determinant
        py = np.linalg.det(cov)
        f90 = fort.wrapper_determinant(cov)

        np.testing.assert_allclose(py, f90, rtol=1e-05, atol=1e-06)

        # Trace
        py = np.trace(cov)
        f90 = fort.wrapper_trace(cov)

        np.testing.assert_allclose(py, f90, rtol=1e-05, atol=1e-06)

        # Cholesky decomposition
        f90 = fort.wrapper_cholesky(cov, dim)
        py = np.linalg.cholesky(cov)

        np.testing.assert_allclose(py, f90, rtol=1e-05, atol=1e-06)

        # Random normal deviates. This only tests the interface, requires
        # visual inspection in IPYTHON notebook as well.
        fort.wrapper_standard_normal(num_draws)
        fort.wrapper_multivariate_normal(mean, cov, num_draws, dim)


def test_98():
    """  Compare results from the RESTUD program and the ROBUPY package.
    """

    # Ensure that fast solution methods are available
    compile_package('fast')

    # Prepare RESTUD program
    os.chdir('modules')
    os.system(' gfortran -fcheck=bounds -o dp3asim dp3asim.f95 >'
              ' /dev/null 2>&1 ')
    os.remove('pei_additions.mod')
    os.remove('imsl_replacements.mod')
    os.chdir('../')

    # Impose some constraints on the initialization file which ensures that
    # the problem can be solved by the RESTUD code.
    constraints = dict()
    constraints['edu'] = (10, 20)
    constraints['level'] = 0.00
    constraints['debug'] = 'True'

    version = np.random.choice(['FORTRAN', 'F2PY', 'PYTHON'])
    constraints['version'] = version

    # Generate random initialization file. The RESTUD code uses the same random
    # draws for the solution and simulation of the model. Thus, the number of
    # draws is required to be less or equal to the number of agents.
    init_dict = generate_random_dict(constraints)

    num_agents = init_dict['SIMULATION']['agents']
    num_draws = init_dict['SOLUTION']['draws']
    if num_draws < num_agents:
        init_dict['SOLUTION']['draws'] = num_agents

    print_random_dict(init_dict)

    # Let us write out the disturbances to a file so that they can be aligned
    # between the alternative implementations
    num_draws = init_dict['SOLUTION']['draws']
    num_periods = init_dict['BASICS']['periods']

    eps_relevant_periods = np.random.multivariate_normal(np.zeros(4),
        np.identity(4), (num_periods, num_draws))

    for period in range(num_periods):
        for j in [0, 1]:
            eps_relevant_periods[period, :, j] = \
                np.exp(eps_relevant_periods[period, :, j])

    with open('disturbances.txt', 'w') as file_:
        for period in range(num_periods):
            for i in range(num_draws):
                line = ' {0:15.10f} {1:15.10f} {2:15.10f} {3:15.10f}\n'.format(
                    *eps_relevant_periods[period, i, :])
                file_.write(line)

    # Perform toolbox actions
    robupy_obj = read('test.robupy.ini')

    # This flag aligns the random components between the RESTUD program and
    # ROBUPY package. The existence of the file leads to the RESTUD program
    # to write out the random components.
    init_dict = robupy_obj.get_attr('init_dict')

    transform_robupy_to_restud(init_dict)

    # Solve model using RESTUD code.
    os.system('./modules/dp3asim > /dev/null 2>&1')

    # Solve model using ROBUPY package.
    solve(robupy_obj)

    if version in ['F2PY', 'PYTHON']:
        simulate(robupy_obj)

    # Compare the simulated datasets generated by the programs.
    py = pd.DataFrame(np.array(np.genfromtxt('data.robupy.dat',
            missing_values='.'), ndmin=2)[:, -4:])

    fort = pd.DataFrame(np.array(np.genfromtxt('ftest.txt',
            missing_values='.'), ndmin=2)[:, -4:])

    fort.to_csv('fort.dat')
    py.to_csv('py.dat')

    assert_frame_equal(py, fort)

    # Cleanup
    os.unlink('disturbances.txt')


def test_99():
    """ Testing whether the results from a fast and slow execution of the
    code result in identical simulate datasets.
    """
    # Ensure that fast solution methods are available
    compile_package('fast')

    # Constraint to risk model
    constraints = dict()
    constraints['level'] = 0.0

    # Generate random initialization
    init_dict = generate_random_dict(constraints)

    # Initialize containers
    base = None

    for version in ['PYTHON', 'F2PY']:

        # Prepare initialization file
        init_dict['PROGRAM']['version'] = version

        print_random_dict(init_dict)

        # Simulate the ROBUPY package
        os.system('robupy-solve --simulate --model test.robupy.ini')

        # Load simulated data frame
        data_frame = pd.read_csv('data.robupy.dat')

        # Compare
        if base is None:
            base = data_frame.copy()

        assert_frame_equal(base, data_frame)