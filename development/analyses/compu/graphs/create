#!/usr/bin/env python
""" This script creates materials for the lecture on some computational
aspects of the COMPU package.
"""

# standard library
import matplotlib.pylab as plt

from matplotlib.ticker import FuncFormatter
from matplotlib import cm

from multiprocessing import Array
from multiprocessing import Pool

import pickle as pkl

import shutil
import glob
import time
import sys
import os

# module-wide variables
os.chdir(os.path.dirname(os.path.realpath(__file__)))

# PYTHONPATH
sys.path.insert(0, os.environ['ROBUPY'] + '/development/tests/random')
sys.path.insert(0, os.environ['ROBUPY'])

from modules.auxiliary import compile_package

# project library
from robupy.tests.random_init import print_random_dict

import robupy


# module-wide variables
VERSIONS = ['PYTHON', 'F2PY', 'FORTRAN', 'FORTRAN_OPTIMIZATION']
COLORS = ['red', 'orange', 'blue']
PERIODS_GRID = range(1, 10)
NUM_PROCS = 2


''' Auxiliary functions
'''


def plot_profiling(yvals, xvals, name):
    """ Plot profiling results.
    """

    # Auxiliary objects
    versions = xvals.keys()

    # Initialize plot
    ax = plt.figure(figsize=(12, 8)).add_subplot(111)

    # Draw lines
    for i, version in enumerate(versions):
        ax.plot(yvals, xvals[version], '-k', label=version,
            linewidth=5, color=COLORS[i])

    # Both axes
    ax.tick_params(labelsize=16, direction='out', axis='both', top='off',
        right='off')

    # x-axis
    #ax.set_xticklabels(ax.get_xticks().astype(int))
    ax.set_xlabel('Periods', fontsize=16)

    # y-axis
    #yticks = ['{:,.0f}'.format(y) for y in ax.get_yticks().astype(int)]
    #ax.set_yticklabels(yticks, fontsize=16)

    ax.set_ylabel('Seconds', fontsize=16)
    ax.yaxis.get_major_ticks()[0].set_visible(False)

    # Set up legend
    ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.10),
        fancybox=False, frameon=False, shadow=False, ncol=len(versions),
        fontsize=20)

    # Write out to
    plt.savefig(name + '.png', bbox_inches='tight', format='png')



time_list = Array('d', len(PERIODS_GRID))



def timing_periods(periods):

    # Modify estimation request
    init_dict['BASICS']['periods'] = periods

    # Construct separate directories for initialization file to avoid
    # interference of different processes.
    name = str(periods)
    if not os.path.exists(name):
        os.mkdir(name)
    os.chdir(name)

    # Print modified request
    print_random_dict(init_dict)

    # Measure execution time of for estimation
    robupy_obj = robupy.read('test.robupy.ini')

    start_time = time.time()

    robupy.solve(robupy_obj)

    time_list[periods - 1] = time.time() - start_time

    # Cleanup
    os.chdir('../'), shutil.rmtree(name)


# Process baseline model
robupy_obj = robupy.read('model.robupy.ini')
init_dict = robupy_obj.get_attr('init_dict')

# Create benchmarking information by looping over all implementations and
# storing the execution time for numerous number of periods.
rslt = dict()

for count, version in enumerate(VERSIONS):

    # Compile the package for the standard and optimized FORTRAN version.
    if count == 0:
         compile_package('--fortran', True)
    elif count == 3:
        compile_package('--fortran --optimization', True)
    else:
        pass

    # Modify baseline request
    if version in ['FORTRAN_OPTIMIZATION']:
        init_dict['PROGRAM']['version'] = 'FORTRAN'
    else:
        init_dict['PROGRAM']['version'] = version

    # Benchmarking execution time using multiple processes
    p = Pool(NUM_PROCS)
    p.map(timing_periods, PERIODS_GRID)

    # Collect information
    rslt[version] = list(time_list)

# Cleanup and prepare results directory.
for file_ in glob.glob('*.log'):
    os.remove(file_)

if not os.path.exists('rslts'):
    os.mkdir('rslts')

os.chdir('rslts')

# Store for future processing
pkl.dump(rslt, open('rslt_profiling.pkl', 'wb'))

rslt = pkl.load(open('rslt_profiling.pkl', 'rb'))

# Plot the profiling results. First, we plot a comparison of pure FORTRAN to
# pure PYTHON code.
subset = dict()
for version in ['PYTHON', 'FORTRAN']:
    subset[version] = rslt[version]

plot_profiling(PERIODS_GRID, subset, 'profiling')

# Plot the optimized implementations against each other.
subset = dict()
for version in ['F2PY', 'FORTRAN', 'FORTRAN_OPTIMIZATION']:
    subset[version] = rslt[version]

plot_profiling(PERIODS_GRID, subset, 'profiling_fast')
