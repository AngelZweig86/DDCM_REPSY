#!/usr/bin/env python
""" This script creates materials for the lecture on some computational
aspects of the COMPU package.
"""

# standard library
import matplotlib
matplotlib.use('Agg')

import matplotlib.pylab as plt


from multiprocessing import Array
from multiprocessing import Pool
from functools import partial

import pickle as pkl

import argparse
import shutil
import glob
import time
import sys
import os

# module-wide variables
os.chdir(os.path.dirname(os.path.realpath(__file__)))

# PYTHONPATH
sys.path.insert(0, os.environ['ROBUPY'] + '/development/tests/random')
sys.path.insert(0, os.environ['ROBUPY'])

# project library
from modules.auxiliary import compile_package

from robupy.tests.random_init import print_random_dict
from robupy import read
from robupy import solve

# module-wide variables
VERSIONS = ['PYTHON', 'F2PY', 'FORTRAN', 'FORTRAN_OPTIMIZATION']
COLORS = ['red', 'orange', 'blue']
TIME_LIST = Array('d', 100)

''' Auxiliary functions
'''


def distribute_arguments(parser):
    """ Distribute command line arguments.
    """
    # Process command line arguments
    args = parser.parse_args()

    # Extract arguments
    num_procs, is_graphs = args.num_procs,  args.graphs
    max_periods = args.periods

    # Check arguments
    assert (max_periods > 2)
    assert (num_procs > 0)
    assert (is_graphs in [True, False])

    if is_graphs:
        assert (os.path.exists('rslts/rslt_profiling.pkl'))

    # Finishing
    return max_periods, num_procs, is_graphs


def plot_profiling(yvals, xvals, name):
    """ Plot profiling results.
    """
    # Auxiliary objects
    versions = xvals.keys()

    # Initialize plot
    ax = plt.figure(figsize=(12, 8)).add_subplot(111)

    # Draw lines
    for i, version in enumerate(versions):
        ax.plot(yvals, xvals[version], '-k', label=version,
            linewidth=5, color=COLORS[i])

    # Both axes
    ax.tick_params(labelsize=16, direction='out', axis='both', top='off',
        right='off')

    # x-axis
    #ax.set_xticklabels(ax.get_xticks().astype(int))
    ax.set_xlabel('Periods', fontsize=16)

    # y-axis
    #yticks = ['{:,.0f}'.format(y) for y in ax.get_yticks().astype(int)]
    #ax.set_yticklabels(yticks, fontsize=16)

    ax.set_ylabel('Seconds', fontsize=16)
    ax.yaxis.get_major_ticks()[0].set_visible(False)

    # Set up legend
    ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.10),
        fancybox=False, frameon=False, shadow=False, ncol=len(versions),
        fontsize=20)

    # Write out to
    plt.savefig(name + '.png', bbox_inches='tight', format='png')


def plot_graphs(rslt, max_periods):
    """ Plot graphs
    """
    # Auxiliary objects
    periods_grid = range(1, max_periods)

    # Change to results directory, which already contains the serialized
    # results.
    os.chdir('rslts')

    # Plot the profiling results. First, we plot a comparison of pure FORTRAN to
    # pure PYTHON code.
    subset = dict()
    for version in ['PYTHON', 'FORTRAN']:
        subset[version] = rslt[version]
    plot_profiling(periods_grid, subset, 'profiling')

    # Plot the optimized implementations against each other.
    subset = dict()
    for version in ['F2PY', 'FORTRAN', 'FORTRAN_OPTIMIZATION']:
        subset[version] = rslt[version]
    plot_profiling(periods_grid, subset, 'profiling_fast')


def timing_periods(init_dict, periods):
    """ Record execution time for alternative lengths over the life-cycle.
    """
    # Modify estimation request
    init_dict['BASICS']['periods'] = periods

    # Construct separate directories for initialization file to avoid
    # interference of different processes.
    name = str(periods)
    if not os.path.exists(name):
        os.mkdir(name)
    os.chdir(name)

    # Print modified request
    print_random_dict(init_dict)

    # Measure execution time of for estimation
    robupy_obj = read('test.robupy.ini')

    start_time = time.time()

    solve(robupy_obj)

    TIME_LIST[periods - 1] = time.time() - start_time

    # Cleanup
    os.chdir('../'), shutil.rmtree(name)


def create_results(max_periods, num_procs):
    """ Create the results from the benchmarking exercise.
    """
    # Auxiliary objects
    periods_grid = range(1, max_periods)

    # Process baseline model
    robupy_obj = read('model.robupy.ini')
    init_dict = robupy_obj.get_attr('init_dict')

    # Create benchmarking information by looping over all implementations and
    # storing the execution time for numerous number of periods.
    rslt = dict()
    for count, version in enumerate(VERSIONS):

        # Compile the package for the standard and optimized FORTRAN version.
        if count == 0:
            compile_package('--fortran', True)
        elif count == 3:
            compile_package('--fortran --optimization', True)
        else:
            pass

        # Modify baseline request
        if version in ['FORTRAN_OPTIMIZATION']:
            init_dict['PROGRAM']['version'] = 'FORTRAN'
        else:
            init_dict['PROGRAM']['version'] = version

        # Benchmarking execution time using multiple processes
        p = Pool(num_procs)
        p.map(partial(timing_periods, init_dict), periods_grid)

        # Collect information
        rslt[version] = list(TIME_LIST[:max_periods - 1])

    # Cleanup and prepare results directory
    for file_ in glob.glob('*.log'):
        os.remove(file_)

    if not os.path.exists('rslts'):
        os.mkdir('rslts')

    # Store for future processing
    pkl.dump(rslt, open('rslts/profiling.pkl', 'wb'))


''' Execution of module as script.
'''
if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Create material for COMPU lecture.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--procs', action='store', type=int, dest='num_procs',
        default=1, help='use multiple processors')

    parser.add_argument('--graphs', action='store_true', dest='graphs',
        default=False, help='create only graphs')

    parser.add_argument('--periods', action='store', type=int,
        dest='periods', default=3, help='maximum number of periods')

    # Process command line arguments
    max_periods, num_procs, is_graphs = distribute_arguments(parser)

    # Create results from benchmarking exercise
    if not is_graphs:
        os.system('./clean')
        create_results(max_periods, num_procs)

    # Plot the graphs
    rslt = pkl.load(open('rslts/profiling.pkl', 'rb'))
    plot_graphs(rslt, max_periods)
