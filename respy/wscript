#!/usr/bin/env python

from types import MethodType
from subprocess import Popen
from subprocess import PIPE
import numpy as np
import shutil
import shlex
import json
import os

top = '.'
out = '.bld'


def options(ctx):

    ctx.load('compiler_c')

    ctx.load('compiler_fc')

    ctx.add_option('--debug', action='store_true', dest='is_debug',
                   default=False, help='use debug compiler options')

    ctx.add_option('--without_parallelism', action='store_true',
        dest='without_parallelism', default=False, help='without PARALLELISM')

    ctx.add_option('--without_fortran', action='store_true',
        dest='without_fortran', default=False, help='without FORTRAN')

    # This option is convenient in the development process as it allows to
    # later analyze the F2PY testing battery.
    ctx.add_option('--without_f2py', action='store_true',
        dest='without_f2py', default=False, help='without F2PY')


def configure_debug(ctx):
    """ This function determines whether F2PY is supported or not.
    """

    ctx.start_msg('Configuration DEBUG')

    if ctx.options.is_debug:
        is_debug = True
        message = 'True'
    else:
        is_debug = False
        message = 'False'

    ctx.end_msg(message)

    return is_debug


def support_f2py(ctx):
    """ This function determines whether F2PY is supported or not.
    """

    ctx.start_msg('Support F2PY ')

    if ctx.options.without_f2py:
        is_support = False
    else:

        if ctx.env['FORTRAN']:
            is_support = True
        else:
            is_support = False

    ctx.end_msg(is_support)

    return is_support


def support_fortran(ctx):
    """ This function determines whether FORTRAN is supported or not.
    Some tests are duplicated.
    """

    ctx.start_msg('Support FORTRAN ')

    if ctx.options.without_fortran:
        is_support = False
    else:
        try:

            # Load compiler
            ctx.load('compiler_fc')

            try:
                assert ctx.env.FC_NAME == 'GFORTRAN'
            except AssertionError:
                raise ctx.errors.ConfigurationError

            # Compile a small FORTRAN program
            ctx.check_fortran()

            # Check for LAPACK library
            ctx.check_fc(lib='lapack')

        except ctx.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    ctx.end_msg(is_support)

    return is_support


def support_parallelism(ctx):
    """ This function determines whether parallelism is supported or not.
    Some tests are duplicated.
    """

    ctx.start_msg('Support PARALLELISM ')

    if ctx.options.without_parallelism or ctx.options.without_fortran:
        is_support = False
    else:

        try:
            # Check for the existence of the compiler
            ctx.find_program('mpif90')

            # Check for MPICH implementation and version
            implementation, version = _get_mpif90_details(ctx)
            if implementation not in ['MPICH']:
                raise ctx.errors.ConfigurationError

            if int(version.split('.')[0]) < 3:
                raise ctx.errors.ConfigurationError

        except ctx.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    ctx.end_msg(is_support)

    return is_support


def configure(ctx):

    # Configuration
    ctx.env['DEBUG'] = MethodType(configure_debug, ctx)()

    ctx.env['PARALLELISM'] = MethodType(support_parallelism, ctx)()
    ctx.env['FORTRAN'] = MethodType(support_fortran, ctx)()
    ctx.env['F2PY'] = MethodType(support_f2py, ctx)()

    # We need more details for the case of parallelism.
    if ctx.env['PARALLELISM']:
        ctx.env['FC'] = 'mpif90'
        ctx.env['COMPILER_FORTRAN'] = 'mpif90'

    # We need a small configuration file, that allow to easily access what
    # the exact version of the executable is.
    config_dict = dict()
    config_dict['DEBUG'] = ctx.env['DEBUG']

    config_dict['PARALLELISM'] = ctx.env['PARALLELISM']
    config_dict['FORTRAN'] = ctx.env['FORTRAN']
    config_dict['F2PY'] = ctx.env['F2PY']
    with open('.config', 'w') as outfile:
        json.dump(config_dict, outfile)

    if not ctx.env['FORTRAN']:
        return

    # Enable static libraries
    ctx.env.append_unique('STLIBPATH', ['../.bld/fortran'])
    ctx.env.append_unique('STLIB', ['resfort'])

    # Enable shared libraries
    ctx.env.append_unique('LIB', ['lapack'])

    # Set of compiler options.
    flags_production = ['-O3', '-ffree-line-length-0', '-cpp']

    flags_debug = []
    flags_debug += ['-O', '-Wall', '-Wline-truncation']
    flags_debug += ['-Wsurprising', '-Waliasing', '-Wimplicit-interface']
    flags_debug += ['-Wunused-parameter', '-fwhole-file', '-fcheck=all']
    flags_debug += ['-fbacktrace', '-g', '-fmax-errors=1']
    flags_debug += ['-ffree-line-length-0', '-cpp', '-Wcharacter-truncation']

    # The build is currently only tested for GFORTRAN.
    if ctx.env['DEBUG']:
        ctx.env.append_unique('FCFLAGS', flags_debug)
    else:
        ctx.env.append_unique('FCFLAGS', flags_production)


def build(ctx):

    ctx.add_pre_fun(pre)

    if ctx.env['FORTRAN']:

        ctx.recurse('fortran')

        ctx.add_group()

        ctx.add_post_fun(post)

        # Even when the F2PY interface is not build, we still compile the
        # DP3ASIM executable from the original paper.
        ctx.recurse('tests/resources')

        ctx.add_group()


def post(ctx):
    """ This function performs some housekeeping tasks. We keep all the
    executables in a single directory.
    """
    subdir = 'fortran/bin'

    # Copy the RESFORT executable back to package directory
    os.mkdir(subdir)
    shutil.copy('.bld/fortran/resfort', subdir)

    if ctx.env['PARALLELISM']:
        shutil.copy('.bld/fortran/resfort_slave', subdir)

    # Copy the KW executable.
    src = '.bld/tests/resources/kw_dp3asim'
    shutil.copy(src, 'tests/resources')


def pre(ctx):
    """ Clean up some directories.
    """

    if os.path.exists('fortran/bin'):
        shutil.rmtree('fortran/bin')

    if os.path.exists('tests/resources/kw_dp3asim'):
        os.unlink('tests/resources/kw_dp3asim')


def _get_mpif90_details(ctx):

    output, _ = Popen(['mpif90', '-v'], stdout=PIPE, stderr=PIPE).communicate()

    # In PYTHON 2, output is already a string, but in PYTHON 3 we need to
    # decode it first.
    try:
        output = output.decode()
    except AttributeError:
        pass

    # Now we can process the information independent of PYTHON 2 or PYTHON 3.
    try:
        implementation, version = np.array(shlex.split(output))[[2, 4]]
    except:
        raise ctx.errors.ConfigurationError

    return implementation, version
