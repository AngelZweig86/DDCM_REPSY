from subprocess import Popen
from subprocess import PIPE
import numpy as np
import shlex
import json

from waflib.Configure import conf

top = '.'
out = '.bld'

# GFORTRAN FLAGS, it would nice to add  '-ffpe-trap=zero,overflow,invalid' back to the debug
# flags, however this results in a failure of the KW1994 codes and we cannot just turn it off
# for their files. This does not seem straightforward as the all the flags are set in the
# configure phase.
GFORTRAN_FLAGS = ['-ffree-line-length-0', '-cpp', '-fopenmp']

GFORTRAN_FLAGS_DEBUG = []
GFORTRAN_FLAGS_DEBUG += ['-O', '-Wall', '-Wline-truncation', '-Wsurprising', '-Waliasing']
GFORTRAN_FLAGS_DEBUG += ['-Wunused-parameter', '-fwhole-file', '-fcheck=all']
GFORTRAN_FLAGS_DEBUG += ['-fbacktrace', '-g', '-fmax-errors=1', '-fopt-info-all=fopt.log']
GFORTRAN_FLAGS_DEBUG += ['-Wcharacter-truncation', '-Wimplicit-interface']

GFORTRAN_FLAGS_PRODUCTION = ['-O3']


def options(ctx):

    ctx.load('compiler_c')

    ctx.load('compiler_fc')

    ctx.add_option('--debug', action='store_true', dest='is_debug', help='use debug compiler flags')

    ctx.add_option('--no_mpi', action='store_true', dest='no_mpi',
                   help='no support for MPI parallelism')

    ctx.add_option('--no_omp', action='store_true', dest='no_omp',
                   help='no support for OMP parallelism')

    ctx.add_option('--no_fortran', action='store_true', dest='no_fortran',
        help='no support for FORTRAN')

    # This option is convenient in the development process as it allows to later analyze the F2PY
    # testing battery.
    ctx.add_option('--no_f2py', action='store_true', dest='no_f2py', help='no support for F2PY')


def configure(ctx):

    ctx.env['DEBUG'] = ctx.configure_debug()
    ctx.env['FORTRAN'] = ctx.check_support_fortran()
    ctx.env['F2PY'] = ctx.check_support_f2py()

    # This needs to be checked after FORTRAN is checked, only then the required tools are available.
    ctx.env['PARALLELISM_MPI'] = ctx.check_support_parallelism_mpi()
    ctx.env['PARALLELISM_OMP'] = ctx.check_support_parallelism_omp()

    ctx.write_configuration()

    if ctx.env['FORTRAN']:
        ctx.env.append_unique('STLIBPATH', ['../.bld/fortran', '../.bld/tests/resources'])
        ctx.env.append_unique('LIB', ['lapack'])

        ctx.env.append_unique('FCFLAGS', GFORTRAN_FLAGS)
        if ctx.env['DEBUG']:
            ctx.env.append_unique('FCFLAGS', GFORTRAN_FLAGS_DEBUG)
        else:
            ctx.env.append_unique('FCFLAGS', GFORTRAN_FLAGS_PRODUCTION)

    if ctx.env['PARALLELISM_MPI']:
        ctx.env['FC'] = 'mpif90'
        ctx.env.append_unique('FCFLAGS', ['-DMPI_AVAILABLE'])

    if ctx.env['PARALLELISM_OMP']:
        ctx.env.append_unique('LINKFLAGS', ['-fopenmp'])
        ctx.env.append_unique('FCFLAGS', ['-DOMP_AVAILABLE'])


def build(ctx):

    if ctx.env['FORTRAN']:

        ctx.recurse('fortran')

        ctx.recurse('tests/resources')


@conf
def configure_debug(self):
    """This function determines whether F2PY is supported or not."""
    self.start_msg('Configuration DEBUG')

    if self.options.is_debug:
        is_debug = True
        message = 'True'
    else:
        is_debug = False
        message = 'False'

    self.end_msg(message)

    return is_debug


@conf
def check_support_f2py(self):
    """This function determines whether F2PY is supported or not."""
    self.start_msg('Support F2PY ')

    if self.options.no_f2py:
        is_support = False
    else:
        if self.env['FORTRAN']:
            is_support = True
        else:
            is_support = False

    self.end_msg(is_support)

    return is_support


@conf
def check_support_fortran(self):
    """This function determines whether FORTRAN is supported or not."""
    self.start_msg('Support FORTRAN ')

    if self.options.no_fortran:
        is_support = False
    else:
        try:
            self.load('compiler_fc')
            try:
                assert self.env.FC_NAME == 'GFORTRAN'
            except AssertionError:
                raise self.errors.ConfigurationError
            self.check_fortran()
            self.check_fc(lib='lapack')

        except self.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    self.end_msg(is_support)

    return is_support


@conf
def check_support_parallelism_mpi(self):
    """This function determines whether MPI parallelism is supported or not."""
    self.start_msg('Support MPI PARALLELISM ')

    if self.options.no_mpi or self.options.no_fortran:
        is_support = False
    else:
        try:
            self.find_program('mpif90')
            check_mpi_implementation(self)
        except self.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    self.end_msg(is_support)

    return is_support


@conf
def check_support_parallelism_omp(self):
    """This function determines whether OMP parallelism is supported or not."""
    self.start_msg('Support OMP PARALLELISM ')

    if self.options.no_omp or self.options.no_fortran:
        is_support = False
    else:
        try:
            self.detect_openmp()
        except self.errors.ConfigurationError:
            is_support = False
        else:
            is_support = True

    self.end_msg(is_support)

    return is_support

@conf
def check_mpi_implementation(self):
    """This function checks for the version of the MPICH implementation."""
    output = Popen(['mpif90', '-v'], stdout=PIPE, stderr=PIPE).communicate()[0].decode()
    implementation, version = np.array(shlex.split(output))[[2, 4]]

    # The build process is only tested for MPICH at this point.
    if implementation not in ['MPICH']:
        raise self.errors.ConfigurationError

    # We need at least version 3 to implement the master-slave paradigm.
    if int(version.split('.')[0]) < 3:
        raise self.errors.ConfigurationError


@conf
def write_configuration(self):
    """This function records the package specification in a simple file."""
    config_dict = dict()
    for label in ['DEBUG', 'FORTRAN', 'F2PY', 'PARALLELISM_MPI', 'PARALLELISM_OMP']:
        config_dict[label] = self.env[label]
    json.dump(config_dict, open('.bld/.config', 'w'))
