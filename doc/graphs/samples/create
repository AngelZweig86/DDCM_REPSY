#!/usr/bin/env python
""" This module produces the graphs for the lecture on the RESTUD economies.
"""

# standard library
import numpy as np

import shutil
import sys
import os

sys.path.insert(0, 'modules/')

# hand-crafted plots
from auxiliary import plot_dimension_state_space
from auxiliary import get_choice_probabilities
from auxiliary import plot_return_experience
from auxiliary import plot_return_education
from auxiliary import return_to_experience
from auxiliary import return_to_education
from auxiliary import plot_choice_patterns

# module-wide variables
HOME = os.path.dirname(os.path.realpath(__file__))

# project library
import respy

#
# try:
#     shutil.rmtree('rslts')
# except OSError:
#     pass
#
# os.mkdir('rslts')
#
# os.chdir('rslts')
# for spec in ['data_one', 'data_two', 'data_three']:
#     os.mkdir(spec)
# os.chdir('../')

# Wage functions
coeffs = {}

for spec in ['one', 'two', 'three']:

    coeffs[spec] = dict()

    respy_obj = respy.RespyCls('../../../example/kw_data_' + spec + '.ini')

    os.chdir('rslts/data_' + spec)
    #respy.simulate(respy_obj)
    os.chdir('../../')

    model_paras = respy_obj.get_attr('model_paras')

    for label in ['a', 'b']:
        coeffs[spec][label] = model_paras['coeffs_' + label]

    # Also plot the state space.
    #if spec == 'one':
    #    num_states = respy_obj.get_attr('states_number_period')
    #    plot_dimension_state_space(num_states)

# Determine wages for varying level of experience in each occupation
for spec in ['one', 'two', 'three']:
    z = dict()
    for which in ['a', 'b']:
        x, y = np.meshgrid(range(20), range(20))
        z[which] = np.tile(np.nan, (20,20))
        for i in range(20):
            for j in range(20):
                z[which][i, j] = return_to_experience(i, j, coeffs[spec], which)
    # Create and save plot
    plot_return_experience(x, y, z, spec)
#
# # Determine wages for varying years of education in each occupation
# for spec in ['one', 'two', 'three']:
#     xvals, yvals = range(10, 21), dict()
#     for which in ['a', 'b']:
#         yvals[which] = []
#         for edu in xvals:
#             yvals[which] += [return_to_education(edu, coeffs[spec], which)]
#
#     # Create and save plot
#     plot_return_education(xvals, yvals, spec)
#
# # Determine choice patterns over time
# for spec in ['one', 'two', 'three']:
#
#     os.chdir('rslts/data_' + spec)
#     choice_probabilities = get_choice_probabilities('data.respy.info')
#     plot_choice_patterns(choice_probabilities, spec)
#     os.chdir(HOME)
